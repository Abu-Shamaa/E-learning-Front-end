{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Remove all accentuated characters from a string\n */\n\nconst stripAccents = input => {\n  const accents = \"ÀÁÂÃÄÅĄàáâãäåąÒÓÔÕÕÖØòóôõöøÈÉÊËĘèéêëðęÇĆçćÐÌÍÎÏìíîïÙÚÛÜùúûüÑñŠŚšśŸÿýŽŹŻžźżŁłŃńàáãảạăằắẳẵặâầấẩẫậèéẻẽẹêềếểễệđùúủũụưừứửữựòóỏõọôồốổỗộơờớởỡợìíỉĩịäëïîüûñçýỳỹỵỷğışĞİŞ\";\n  const fixes = \"AAAAAAAaaaaaaaOOOOOOOooooooEEEEEeeeeeeCCccDIIIIiiiiUUUUuuuuNnSSssYyyZZZzzzLlNnaaaaaaaaaaaaaaaaaeeeeeeeeeeeduuuuuuuuuuuoooooooooooooooooiiiiiaeiiuuncyyyyygisGIS\";\n  const split = accents.split(\"\").join(\"|\");\n  const reg = new RegExp(`(${split})`, \"g\");\n\n  function replacement(a) {\n    return fixes[accents.indexOf(a)] || \"\";\n  }\n\n  return input.replace(reg, replacement);\n};\n\nconst getSafeRegexpString = input => input.split(\"\").map(char => `\\\\${char}`).join(\"\");\n/**\n * Harmonize a string by removing spaces, non-alphabetical caracters and by\n * adding delimiter\n */\n\n\nconst harmonize = function (input, delimiter) {\n  let ignoreInvalid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const harmonized = stripAccents(input).trim().toLowerCase();\n  const safeDelimiter = getSafeRegexpString(delimiter);\n\n  if (ignoreInvalid) {\n    return harmonized.replace(/\\s+/g, delimiter);\n  }\n\n  return harmonized.replace(new RegExp(`[^a-z0-9${safeDelimiter}]+`, \"g\"), delimiter) // Replace all non-valid caracters by delimiter\n  .replace(new RegExp(`${safeDelimiter}+`, \"g\"), delimiter) // Remove multiple delimiters repetition\n  .replace(new RegExp(`^${safeDelimiter}`, \"g\"), \"\") // remove delimiter at the beginning\n  .replace(new RegExp(`${safeDelimiter}$`, \"g\"), \"\"); // remove delimiter at the end\n};\n/**\n * Slugify a React node\n */\n\n\nconst slugify = function (node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    delimiter: \"-\",\n    prefix: \"\"\n  };\n  if (!options.delimiter) options.delimiter = \"-\";\n  if (!options.prefix) options.prefix = \"\";\n\n  if (!node || typeof node === \"boolean\") {\n    return \"\";\n  }\n\n  const {\n    delimiter,\n    prefix\n  } = options; // boolean\n\n  if (typeof node === \"boolean\") {\n    return \"\"; // not much we can do here\n  } // string, number\n\n\n  if (typeof node === \"string\" || typeof node === \"number\") {\n    const harmonizedPrefix = harmonize(prefix, delimiter, true);\n    const harmonizedNode = harmonize(String(node), delimiter);\n\n    if (harmonizedPrefix) {\n      return `${harmonizedPrefix}${delimiter}${harmonizedNode}`;\n    }\n\n    return harmonizedNode;\n  } // ReactPortal\n\n\n  if (\"children\" in node) {\n    return slugify(node.children);\n  } // ReactElement\n\n\n  if (\"type\" in node) return slugify(node.props.children, options); // ReactFragment (including array of nodes)\n\n  if (Symbol.iterator in node) {\n    return slugify(Array.from(node).map(subNode => slugify(subNode, {\n      delimiter\n    })).join(delimiter), options);\n  } // unhandled case\n\n\n  return \"\";\n};\n\nexports.default = slugify;","map":{"version":3,"mappings":"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","names":["stripAccents","input","accents","fixes","split","join","reg","RegExp","replacement","a","indexOf","replace","getSafeRegexpString","map","char","harmonize","delimiter","ignoreInvalid","harmonized","trim","toLowerCase","safeDelimiter","slugify","node","options","prefix","harmonizedPrefix","harmonizedNode","String","children","props","Symbol","iterator","Array","from","subNode","exports"],"sources":["/home/shama/webapps/ionicblog/node_modules/react-slugify/src/slugify.ts"],"sourcesContent":["import * as React from \"react\";\n\n/**\n * Remove all accentuated characters from a string\n */\nconst stripAccents = (input: string): string => {\n  const accents =\n    \"ÀÁÂÃÄÅĄàáâãäåąÒÓÔÕÕÖØòóôõöøÈÉÊËĘèéêëðęÇĆçćÐÌÍÎÏìíîïÙÚÛÜùúûüÑñŠŚšśŸÿýŽŹŻžźżŁłŃńàáãảạăằắẳẵặâầấẩẫậèéẻẽẹêềếểễệđùúủũụưừứửữựòóỏõọôồốổỗộơờớởỡợìíỉĩịäëïîüûñçýỳỹỵỷğışĞİŞ\";\n  const fixes =\n    \"AAAAAAAaaaaaaaOOOOOOOooooooEEEEEeeeeeeCCccDIIIIiiiiUUUUuuuuNnSSssYyyZZZzzzLlNnaaaaaaaaaaaaaaaaaeeeeeeeeeeeduuuuuuuuuuuoooooooooooooooooiiiiiaeiiuuncyyyyygisGIS\";\n  const split = accents.split(\"\").join(\"|\");\n  const reg = new RegExp(`(${split})`, \"g\");\n\n  function replacement(a: string) {\n    return fixes[accents.indexOf(a)] || \"\";\n  }\n\n  return input.replace(reg, replacement);\n};\n\nconst getSafeRegexpString = (input: string): string =>\n  input\n    .split(\"\")\n    .map((char) => `\\\\${char}`)\n    .join(\"\");\n\n/**\n * Harmonize a string by removing spaces, non-alphabetical caracters and by\n * adding delimiter\n */\nconst harmonize = (\n  input: string,\n  delimiter: string,\n  ignoreInvalid = false\n): string => {\n  const harmonized = stripAccents(input).trim().toLowerCase();\n  const safeDelimiter = getSafeRegexpString(delimiter);\n\n  if (ignoreInvalid) {\n    return harmonized.replace(/\\s+/g, delimiter);\n  }\n\n  return harmonized\n    .replace(new RegExp(`[^a-z0-9${safeDelimiter}]+`, \"g\"), delimiter) // Replace all non-valid caracters by delimiter\n    .replace(new RegExp(`${safeDelimiter}+`, \"g\"), delimiter) // Remove multiple delimiters repetition\n    .replace(new RegExp(`^${safeDelimiter}`, \"g\"), \"\") // remove delimiter at the beginning\n    .replace(new RegExp(`${safeDelimiter}$`, \"g\"), \"\"); // remove delimiter at the end\n};\n\ninterface SlugifyOptions {\n  delimiter?: string;\n  prefix?: string;\n}\n\n/**\n * Slugify a React node\n */\nconst slugify = (\n  node: React.ReactNode,\n  options: SlugifyOptions = { delimiter: \"-\", prefix: \"\" }\n): string => {\n  if (!options.delimiter) options.delimiter = \"-\";\n  if (!options.prefix) options.prefix = \"\";\n\n  if (!node || typeof node === \"boolean\") {\n    return \"\";\n  }\n\n  const { delimiter, prefix } = options;\n\n  // boolean\n  if (typeof node === \"boolean\") {\n    return \"\"; // not much we can do here\n  }\n\n  // string, number\n  if (typeof node === \"string\" || typeof node === \"number\") {\n    const harmonizedPrefix = harmonize(prefix, delimiter, true);\n    const harmonizedNode = harmonize(String(node), delimiter);\n\n    if (harmonizedPrefix) {\n      return `${harmonizedPrefix}${delimiter}${harmonizedNode}`;\n    }\n\n    return harmonizedNode;\n  }\n\n  // ReactPortal\n  if (\"children\" in node) {\n    return slugify(node.children);\n  }\n\n  // ReactElement\n  if (\"type\" in node) return slugify(node.props.children, options);\n\n  // ReactFragment (including array of nodes)\n  if (Symbol.iterator in node) {\n    return slugify(\n      Array.from(node)\n        .map((subNode) => slugify(subNode, { delimiter }))\n        .join(delimiter),\n      options\n    );\n  }\n\n  // unhandled case\n  return \"\";\n};\n\nexport default slugify;\n"]},"metadata":{},"sourceType":"script"}