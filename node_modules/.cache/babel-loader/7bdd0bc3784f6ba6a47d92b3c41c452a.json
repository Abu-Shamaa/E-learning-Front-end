{"ast":null,"code":"/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.mjs';\nimport { memo } from './utils.mjs';\nexport { memo } from './utils.mjs'; //\n//\n\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\n\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.startIndex - range.overscan, 0);\n  var end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  var arr = [];\n\n  for (var _i = start; _i <= end; _i++) {\n    arr.push(_i);\n  }\n\n  return arr;\n};\n\nvar memoRectCallback = function memoRectCallback(instance, cb) {\n  var prev = {\n    height: -1,\n    width: -1\n  };\n  return function (rect) {\n    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n      cb(rect);\n    }\n\n    prev = rect;\n  };\n};\n\nvar observeElementRect = function observeElementRect(instance, cb) {\n  var observer = new ResizeObserver(function (entries) {\n    var _entries$, _entries$2;\n\n    cb({\n      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,\n      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height\n    });\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  cb(instance.scrollElement.getBoundingClientRect());\n  observer.observe(instance.scrollElement);\n  return function () {\n    observer.unobserve(instance.scrollElement);\n  };\n};\n\nvar observeWindowRect = function observeWindowRect(instance, cb) {\n  var memoizedCallback = memoRectCallback(instance, cb);\n\n  var onResize = function onResize() {\n    return memoizedCallback({\n      width: instance.scrollElement.innerWidth,\n      height: instance.scrollElement.innerHeight\n    });\n  };\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  onResize();\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true\n  });\n  return function () {\n    instance.scrollElement.removeEventListener('resize', onResize);\n  };\n};\n\nvar scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY']\n};\n\nvar createOffsetObserver = function createOffsetObserver(mode) {\n  return function (instance, cb) {\n    if (!instance.scrollElement) {\n      return;\n    }\n\n    var propX = scrollProps[mode][0];\n    var propY = scrollProps[mode][1];\n    var prevX = instance.scrollElement[propX];\n    var prevY = instance.scrollElement[propY];\n\n    var scroll = function scroll() {\n      var offset = instance.scrollElement[instance.options.horizontal ? propX : propY];\n      cb(offset);\n    };\n\n    scroll();\n\n    var onScroll = function onScroll(e) {\n      var target = e.currentTarget;\n      var scrollX = target[propX];\n      var scrollY = target[propY];\n\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll();\n      }\n\n      prevX = scrollX;\n      prevY = scrollY;\n    };\n\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      instance.scrollElement.removeEventListener('scroll', onScroll);\n    };\n  };\n};\n\nvar observeElementOffset = createOffsetObserver('element');\nvar observeWindowOffset = createOffsetObserver('window');\n\nvar measureElement = function measureElement(element, instance) {\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height']);\n};\n\nvar windowScroll = function windowScroll(offset, _ref, instance) {\n  var _instance$scrollEleme, _instance$scrollEleme2;\n\n  var _ref$adjustments = _ref.adjustments,\n      adjustments = _ref$adjustments === void 0 ? 0 : _ref$adjustments,\n      behavior = _ref.behavior;\n  var toOffset = offset + adjustments;\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo((_instance$scrollEleme2 = {}, _instance$scrollEleme2[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme2.behavior = behavior, _instance$scrollEleme2));\n};\n\nvar elementScroll = function elementScroll(offset, _ref2, instance) {\n  var _instance$scrollEleme3, _instance$scrollEleme4;\n\n  var _ref2$adjustments = _ref2.adjustments,\n      adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments,\n      behavior = _ref2.behavior;\n  var toOffset = offset + adjustments;\n  (_instance$scrollEleme3 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme3.scrollTo == null ? void 0 : _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));\n};\n\nvar Virtualizer = function Virtualizer(_opts) {\n  var _this = this;\n\n  this.unsubs = [];\n  this.scrollElement = null;\n  this.isScrolling = false;\n  this.isScrollingTimeoutId = null;\n  this.measurementsCache = [];\n  this.itemSizeCache = {};\n  this.pendingMeasuredCacheIndexes = [];\n  this.scrollDirection = null;\n  this.scrollAdjustments = 0;\n  this.measureElementCache = {};\n  this.pendingScrollToIndexCallback = null;\n\n  this.getResizeObserver = function () {\n    var _ro = null;\n    return function () {\n      if (_ro) {\n        return _ro;\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return _ro = new ResizeObserver(function (entries) {\n          entries.forEach(function (entry) {\n            _this._measureElement(entry.target, false);\n          });\n        });\n      } else {\n        return null;\n      }\n    };\n  }();\n\n  this.range = {\n    startIndex: 0,\n    endIndex: 0\n  };\n\n  this.setOptions = function (opts) {\n    Object.entries(opts).forEach(function (_ref3) {\n      var key = _ref3[0],\n          value = _ref3[1];\n      if (typeof value === 'undefined') delete opts[key];\n    });\n    _this.options = _extends({\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: function onChange() {},\n      measureElement: measureElement,\n      initialRect: {\n        width: 0,\n        height: 0\n      },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: []\n    }, opts);\n  };\n\n  this.notify = function () {\n    _this.options.onChange == null ? void 0 : _this.options.onChange(_this);\n  };\n\n  this.cleanup = function () {\n    _this.unsubs.filter(Boolean).forEach(function (d) {\n      return d();\n    });\n\n    _this.unsubs = [];\n    _this.scrollElement = null;\n  };\n\n  this._didMount = function () {\n    var ro = _this.getResizeObserver();\n\n    Object.values(_this.measureElementCache).forEach(function (node) {\n      return ro == null ? void 0 : ro.observe(node);\n    });\n    return function () {\n      ro == null ? void 0 : ro.disconnect();\n\n      _this.cleanup();\n    };\n  };\n\n  this._willUpdate = function () {\n    _this.pendingScrollToIndexCallback == null ? void 0 : _this.pendingScrollToIndexCallback();\n\n    var scrollElement = _this.options.getScrollElement();\n\n    if (_this.scrollElement !== scrollElement) {\n      _this.cleanup();\n\n      _this.scrollElement = scrollElement;\n\n      _this._scrollToOffset(_this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined\n      });\n\n      _this.unsubs.push(_this.options.observeElementRect(_this, function (rect) {\n        _this.scrollRect = rect;\n\n        _this.calculateRange();\n      }));\n\n      _this.unsubs.push(_this.options.observeElementOffset(_this, function (offset) {\n        _this.scrollAdjustments = 0;\n\n        if (_this.scrollOffset === offset) {\n          return;\n        }\n\n        if (_this.isScrollingTimeoutId !== null) {\n          clearTimeout(_this.isScrollingTimeoutId);\n          _this.isScrollingTimeoutId = null;\n        }\n\n        var onIsScrollingChange = function onIsScrollingChange(isScrolling) {\n          if (_this.isScrolling !== isScrolling) {\n            _this.isScrolling = isScrolling;\n\n            _this.notify();\n          }\n        };\n\n        _this.scrollDirection = _this.scrollOffset < offset ? 'forward' : 'backward';\n        _this.scrollOffset = offset;\n\n        _this.calculateRange();\n\n        onIsScrollingChange(true);\n        _this.isScrollingTimeoutId = setTimeout(function () {\n          _this.isScrollingTimeoutId = null;\n          _this.scrollDirection = null;\n          onIsScrollingChange(false);\n        }, _this.options.scrollingDelay);\n      }));\n    } else if (!_this.isScrolling) {\n      _this.calculateRange();\n    }\n  };\n\n  this.getSize = function () {\n    return _this.scrollRect[_this.options.horizontal ? 'width' : 'height'];\n  };\n\n  this.getMeasurements = memo(function () {\n    return [_this.options.count, _this.options.paddingStart, _this.options.scrollMargin, _this.options.getItemKey, _this.itemSizeCache];\n  }, function (count, paddingStart, scrollMargin, getItemKey, itemSizeCache) {\n    var min = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;\n    _this.pendingMeasuredCacheIndexes = [];\n\n    var measurements = _this.measurementsCache.slice(0, min);\n\n    for (var _i2 = min; _i2 < count; _i2++) {\n      var key = getItemKey(_i2);\n      var measuredSize = itemSizeCache[key];\n      var start = measurements[_i2 - 1] ? measurements[_i2 - 1].end : paddingStart + scrollMargin;\n      var size = typeof measuredSize === 'number' ? measuredSize : _this.options.estimateSize(_i2);\n      var end = start + size;\n      measurements[_i2] = {\n        index: _i2,\n        start: start,\n        size: size,\n        end: end,\n        key: key\n      };\n    }\n\n    _this.measurementsCache = measurements;\n    return measurements;\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.calculateRange = memo(function () {\n    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];\n  }, function (measurements, outerSize, scrollOffset) {\n    var range = calculateRange({\n      measurements: measurements,\n      outerSize: outerSize,\n      scrollOffset: scrollOffset\n    });\n\n    if (range.startIndex !== _this.range.startIndex || range.endIndex !== _this.range.endIndex) {\n      _this.range = range;\n\n      _this.notify();\n    }\n\n    return _this.range;\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.getIndexes = memo(function () {\n    return [_this.options.rangeExtractor, _this.range, _this.options.overscan, _this.options.count];\n  }, function (rangeExtractor, range, overscan, count) {\n    return rangeExtractor(_extends({}, range, {\n      overscan: overscan,\n      count: count\n    }));\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n\n  this.indexFromElement = function (node) {\n    var attributeName = _this.options.indexAttribute;\n    var indexStr = node.getAttribute(attributeName);\n\n    if (!indexStr) {\n      console.warn(\"Missing attribute name '\" + attributeName + \"={index}' on measured element.\");\n      return -1;\n    }\n\n    return parseInt(indexStr, 10);\n  };\n\n  this._measureElement = function (node, _sync) {\n    var _this$itemSizeCache$i;\n\n    var index = _this.indexFromElement(node);\n\n    var item = _this.measurementsCache[index];\n\n    if (!item) {\n      return;\n    }\n\n    var prevNode = _this.measureElementCache[item.key];\n\n    var ro = _this.getResizeObserver();\n\n    if (!node.isConnected) {\n      if (prevNode) {\n        ro == null ? void 0 : ro.unobserve(prevNode);\n        delete _this.measureElementCache[item.key];\n      }\n\n      return;\n    }\n\n    if (!prevNode || prevNode !== node) {\n      if (prevNode) {\n        ro == null ? void 0 : ro.unobserve(prevNode);\n      }\n\n      _this.measureElementCache[item.key] = node;\n      ro == null ? void 0 : ro.observe(node);\n    }\n\n    var measuredItemSize = _this.options.measureElement(node, _this);\n\n    var itemSize = (_this$itemSizeCache$i = _this.itemSizeCache[item.key]) != null ? _this$itemSizeCache$i : item.size;\n    var delta = measuredItemSize - itemSize;\n\n    if (delta !== 0) {\n      var _extends2;\n\n      if (item.start < _this.scrollOffset && _this.isScrolling && _this.scrollDirection === 'backward') {\n        if (process.env.NODE_ENV !== 'production' && _this.options.debug) {\n          console.info('correction', delta);\n        }\n\n        _this._scrollToOffset(_this.scrollOffset, {\n          adjustments: _this.scrollAdjustments += delta,\n          behavior: undefined\n        });\n      }\n\n      _this.pendingMeasuredCacheIndexes.push(index);\n\n      _this.itemSizeCache = _extends({}, _this.itemSizeCache, (_extends2 = {}, _extends2[item.key] = measuredItemSize, _extends2));\n\n      _this.notify();\n    }\n  };\n\n  this.measureElement = function (node) {\n    if (!node) {\n      return;\n    }\n\n    _this._measureElement(node, true);\n  };\n\n  this.getVirtualItems = memo(function () {\n    return [_this.getIndexes(), _this.getMeasurements()];\n  }, function (indexes, measurements) {\n    var virtualItems = [];\n\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      var _i3 = indexes[k];\n      var measurement = measurements[_i3];\n      virtualItems.push(measurement);\n    }\n\n    return virtualItems;\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n\n  this.getOffsetForAlignment = function (toOffset, align) {\n    var offset = _this.scrollOffset;\n\n    var size = _this.getSize();\n\n    if (align === 'auto') {\n      if (toOffset <= offset) {\n        align = 'start';\n      } else if (toOffset >= offset + size) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n\n    if (align === 'start') {\n      return toOffset;\n    } else if (align === 'end') {\n      return toOffset - size;\n    } else if (align === 'center') {\n      return toOffset - size / 2;\n    }\n\n    return toOffset;\n  };\n\n  this.scrollToOffset = function (toOffset, _temp) {\n    var _ref4 = _temp === void 0 ? {} : _temp,\n        _ref4$align = _ref4.align,\n        align = _ref4$align === void 0 ? 'start' : _ref4$align,\n        behavior = _ref4.behavior;\n\n    var options = {\n      adjustments: undefined,\n      behavior: behavior,\n      sync: false\n    };\n\n    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), options);\n  };\n\n  this.scrollToIndex = function (index, _temp2) {\n    var _ref5 = _temp2 === void 0 ? {} : _temp2,\n        _ref5$align = _ref5.align,\n        align = _ref5$align === void 0 ? 'auto' : _ref5$align,\n        behavior = _ref5.behavior;\n\n    _this.pendingScrollToIndexCallback = null;\n    var offset = _this.scrollOffset;\n\n    var size = _this.getSize();\n\n    var count = _this.options.count;\n\n    var measurements = _this.getMeasurements();\n\n    var measurement = measurements[Math.max(0, Math.min(index, count - 1))];\n\n    if (!measurement) {\n      throw new Error(\"VirtualItem not found for index = \" + index);\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {\n        align = 'end';\n      } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n\n    var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(measurement) {\n      var toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n      return _this.getOffsetForAlignment(toOffset, align);\n    };\n\n    var toOffset = getOffsetForIndexAndAlignment(measurement);\n\n    if (Math.round(toOffset) === Math.round(offset)) {\n      return;\n    }\n\n    var options = {\n      adjustments: undefined,\n      behavior: behavior\n    };\n\n    _this._scrollToOffset(toOffset, options);\n\n    var isDynamic = Object.keys(_this.measureElementCache).length > 0;\n\n    if (isDynamic) {\n      _this.pendingScrollToIndexCallback = function () {\n        _this.scrollToIndex(index, {\n          align: align,\n          behavior: behavior\n        });\n      };\n    }\n  };\n\n  this.scrollBy = function (adjustments, options) {\n    _this._scrollToOffset(_this.scrollOffset, {\n      adjustments: adjustments,\n      behavior: options == null ? void 0 : options.behavior\n    });\n  };\n\n  this.getTotalSize = function () {\n    var _this$getMeasurements;\n\n    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) - _this.options.scrollMargin + _this.options.paddingEnd;\n  };\n\n  this._scrollToOffset = function (offset, _ref6) {\n    var adjustments = _ref6.adjustments,\n        behavior = _ref6.behavior;\n\n    _this.options.scrollToFn(offset, {\n      behavior: behavior,\n      adjustments: adjustments\n    }, _this);\n  };\n\n  this.measure = function () {\n    _this.itemSizeCache = {};\n\n    _this.notify();\n  };\n\n  this.setOptions(_opts);\n  this.scrollRect = this.options.initialRect;\n  this.scrollOffset = this.options.initialOffset;\n  this.measurementsCache = this.options.initialMeasurementsCache;\n  this.measurementsCache.forEach(function (item) {\n    _this.itemSizeCache[item.key] = item.size;\n  });\n  this.calculateRange();\n};\n\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref7) {\n  var measurements = _ref7.measurements,\n      outerSize = _ref7.outerSize,\n      scrollOffset = _ref7.scrollOffset;\n  var count = measurements.length - 1;\n\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n\n  var startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  var endIndex = startIndex;\n\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n\n  return {\n    startIndex: startIndex,\n    endIndex: endIndex\n  };\n}\n\nexport { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };","map":{"version":3,"mappings":";;;;;;;;;;;;oCAIA;AAuCA;;IAEaA,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,KAAD,EAAc;EAAA,OAAKA,KAAL;AAAU;;IAE9CC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACC,KAAD,EAAkB;EACrD,IAAMC,KAAK,GAAGC,IAAI,CAACC,GAALD,CAASF,KAAK,CAACI,UAANJ,GAAmBA,KAAK,CAACK,QAAlCH,EAA4C,CAA5CA,CAAd;EACA,IAAMI,GAAG,GAAGJ,IAAI,CAACK,GAALL,CAASF,KAAK,CAACQ,QAANR,GAAiBA,KAAK,CAACK,QAAhCH,EAA0CF,KAAK,CAACS,KAANT,GAAc,CAAxDE,CAAZ;EAEA,IAAMQ,GAAG,GAAG,EAAZ;;EAEA,KAAK,IAAIC,EAAC,GAAGV,KAAb,EAAoBU,EAAC,IAAIL,GAAzB,EAA8BK,EAAC,EAA/B,EAAmC;IACjCD,GAAG,CAACE,IAAJF,CAASC,EAATD;EACF;;EAEA,OAAOA,GAAP;AACF;;AAEA,IAAMG,gBAAgB,GAAG,SAAnBA,gBAAmB,CACvBC,QADuB,EAEvBC,EAFuB,EAGpB;EACH,IAAIC,IAAU,GAAG;IAAEC,MAAM,EAAE,CAAC,CAAX;IAAcC,KAAK,EAAE,CAAC;EAAtB,CAAjB;EAEA,OAAO,UAACC,IAAD,EAAgB;IACrB,IACEL,QAAQ,CAACM,OAATN,CAAiBO,UAAjBP,GACIK,IAAI,CAACD,KAALC,KAAeH,IAAI,CAACE,KADxBJ,GAEIK,IAAI,CAACF,MAALE,KAAgBH,IAAI,CAACC,MAH3B,EAIE;MACAF,EAAE,CAACI,IAAD,CAAFJ;IACF;;IAEAC,IAAI,GAAGG,IAAPH;EACD,CAVD;AAWD,CAjBD;;AAmBO,IAAMM,kBAAkB,GAAG,SAArBA,kBAAqB,CAChCR,QADgC,EAEhCC,EAFgC,EAG7B;EACH,IAAMQ,QAAQ,GAAG,IAAIC,cAAJ,CAAmB,UAACC,OAAD,EAAa;IAAA;;IAC/CV,EAAE,CAAC;MACDG,KAAK,eAAEO,OAAO,CAAC,CAAD,CAAT,KAAE,IAAF,GAAE,MAAF,GAAEC,UAAYC,WAAZ,CAAwBT,KAD9B;MAEDD,MAAM,gBAAEQ,OAAO,CAAC,CAAD,CAAT,KAAE,IAAF,GAAE,MAAF,GAAEG,WAAYD,WAAZ,CAAwBV;IAF/B,CAAD,CAAFF;EAID,CALgB,CAAjB;;EAOA,IAAI,CAACD,QAAQ,CAACe,aAAd,EAA6B;IAC3B;EACF;;EAEAd,EAAE,CAACD,QAAQ,CAACe,aAATf,CAAuBgB,qBAAvBhB,EAAD,CAAFC;EAEAQ,QAAQ,CAACQ,OAATR,CAAiBT,QAAQ,CAACe,aAA1BN;EAEA,OAAO,YAAM;IACXA,QAAQ,CAACS,SAATT,CAAmBT,QAAQ,CAACe,aAA5BN;EACD,CAFD;AAGF,CAtBO;;AAwBA,IAAMU,iBAAiB,GAAG,SAApBA,iBAAoB,CAC/BnB,QAD+B,EAE/BC,EAF+B,EAG5B;EACH,IAAMmB,gBAAgB,GAAGrB,gBAAgB,CAACC,QAAD,EAAWC,EAAX,CAAzC;;EACA,IAAMoB,QAAQ,GAAG,SAAXA,QAAW,GAAH;IAAA,OACZD,gBAAgB,CAAC;MACfhB,KAAK,EAAEJ,QAAQ,CAACe,aAATf,CAAuBsB,UADf;MAEfnB,MAAM,EAAEH,QAAQ,CAACe,aAATf,CAAuBuB;IAFhB,CAAD,CADJ;EAIV,CAJJ;;EAMA,IAAI,CAACvB,QAAQ,CAACe,aAAd,EAA6B;IAC3B;EACF;;EAEAM,QAAQ;EAERrB,QAAQ,CAACe,aAATf,CAAuBwB,gBAAvBxB,CAAwC,QAAxCA,EAAkDqB,QAAlDrB,EAA4D;IAC1DyB,OAAO,EAAE,KADiD;IAE1DC,OAAO,EAAE;EAFiD,CAA5D1B;EAKA,OAAO,YAAM;IACXA,QAAQ,CAACe,aAATf,CAAuB2B,mBAAvB3B,CAA2C,QAA3CA,EAAqDqB,QAArDrB;EACD,CAFD;AAGF,CAzBO;;AA6BP,IAAM4B,WAAW,GAAG;EAClBC,OAAO,EAAE,CAAC,YAAD,EAAe,WAAf,CADS;EAElBC,MAAM,EAAE,CAAC,SAAD,EAAY,SAAZ;AAFU,CAApB;;AAKA,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,IAAD,EAAwB;EACnD,OAAO,UAAChC,QAAD,EAAkCC,EAAlC,EAAmE;IACxE,IAAI,CAACD,QAAQ,CAACe,aAAd,EAA6B;MAC3B;IACF;;IAEA,IAAMkB,KAAK,GAAGL,WAAW,CAACI,IAAD,CAAXJ,CAAkB,CAAlBA,CAAd;IACA,IAAMM,KAAK,GAAGN,WAAW,CAACI,IAAD,CAAXJ,CAAkB,CAAlBA,CAAd;IAEA,IAAIO,KAAa,GAAGnC,QAAQ,CAACe,aAATf,CAAuBiC,KAAvBjC,CAApB;IACA,IAAIoC,KAAa,GAAGpC,QAAQ,CAACe,aAATf,CAAuBkC,KAAvBlC,CAApB;;IAEA,IAAMqC,MAAM,GAAG,SAATA,MAAS,GAAM;MACnB,IAAMC,MAAM,GACVtC,QAAQ,CAACe,aAATf,CAAuBA,QAAQ,CAACM,OAATN,CAAiBO,UAAjBP,GAA8BiC,KAA9BjC,GAAsCkC,KAA7DlC,CADF;MAGAC,EAAE,CAACqC,MAAD,CAAFrC;IACD,CALD;;IAOAoC,MAAM;;IAEN,IAAME,QAAQ,GAAG,SAAXA,QAAW,CAACC,CAAD,EAAc;MAC7B,IAAMC,MAAM,GAAGD,CAAC,CAACE,aAAjB;MACA,IAAMC,OAAO,GAAGF,MAAM,CAACR,KAAD,CAAtB;MACA,IAAMW,OAAO,GAAGH,MAAM,CAACP,KAAD,CAAtB;;MAEA,IAAIlC,QAAQ,CAACM,OAATN,CAAiBO,UAAjBP,GAA8BmC,KAAK,GAAGQ,OAAtC3C,GAAgDoC,KAAK,GAAGQ,OAA5D,EAAqE;QACnEP,MAAM;MACR;;MAEAF,KAAK,GAAGQ,OAARR;MACAC,KAAK,GAAGQ,OAARR;IACD,CAXD;;IAaApC,QAAQ,CAACe,aAATf,CAAuBwB,gBAAvBxB,CAAwC,QAAxCA,EAAkDuC,QAAlDvC,EAA4D;MAC1DyB,OAAO,EAAE,KADiD;MAE1DC,OAAO,EAAE;IAFiD,CAA5D1B;IAKA,OAAO,YAAM;MACXA,QAAQ,CAACe,aAATf,CAAuB2B,mBAAvB3B,CAA2C,QAA3CA,EAAqDuC,QAArDvC;IACD,CAFD;EAGD,CAzCD;AA0CD,CA3CD;;IA6Ca6C,oBAAoB,GAAGd,oBAAoB,CAAC,SAAD;IAC3Ce,mBAAmB,GAAGf,oBAAoB,CAAC,QAAD;;AAEhD,IAAMgB,cAAc,GAAG,SAAjBA,cAAiB,CAC5BlB,OAD4B,EAE5B7B,QAF4B,EAGzB;EACH,OAAOZ,IAAI,CAAC4D,KAAL5D,CACLyC,OAAO,CAACb,qBAARa,GACE7B,QAAQ,CAACM,OAATN,CAAiBO,UAAjBP,GAA8B,OAA9BA,GAAwC,QAD1C6B,CADKzC,CAAP;AAKF,CATO;;AAWA,IAAM6D,YAAY,GAAG,SAAfA,YAAe,CAC1BX,MAD0B,EAM1BtC,IAN0B,EAM1BA,QAN0B,EAOvB;EAAA;;EAAA,4BAJDkD,WAIC;EAAA,IAJDA,WAAW,iCAAG,CAAH,GAAIC,gBAId;EAAA,IAHDC,QAAQ,QAARA,QAGC;EACH,IAAMC,QAAQ,GAAGf,MAAM,GAAGY,WAA1B;EAEA,iCAAQ,CAACnC,aAAT,2CAAwBuC,QAAxB,0CAAwBA,QAAxB,EAAgCC,oDAC7BvD,QAAQ,CAACM,OAATN,CAAiBO,UAAjBP,GAA8B,MAA9BA,GAAuC,KADV,IACkBqD,QADlB,EAE9BD,0CAF8B,EAG9BG,sBAHF;AAIF,CAdO;;AAgBA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAC3BlB,MAD2B,EAM3BtC,KAN2B,EAM3BA,QAN2B,EAOxB;EAAA;;EAAA,8BAJDkD,WAIC;EAAA,IAJDA,WAAW,kCAAG,CAAH,GAAIO,iBAId;EAAA,IAHDL,QAAQ,SAARA,QAGC;EACH,IAAMC,QAAQ,GAAGf,MAAM,GAAGY,WAA1B;EAEA,kCAAQ,CAACnC,aAAT,4CAAwBuC,QAAxB,2CAAwBA,QAAxB,EAAgCI,oDAC7B1D,QAAQ,CAACM,OAATN,CAAiBO,UAAjBP,GAA8B,MAA9BA,GAAuC,KADV,IACkBqD,QADlB,EAE9BD,0CAF8B,EAG9BM,sBAHF;AAIF,CAdO;;AA+DP,IAAaC,WAAW,GAwCtB,SAAYC,WAAZ,CAAYA,KAAZ,EAAoE;EAAA;;EAAA,KApC5DC,MAoC4D,GApC1B,EAoC0B;EApCxB,KAE5C9C,aAF4C,GAEL,IAFK;EAED,KAC3C+C,WAD2C,GACpB,KADoB;EACf,KACpBC,oBADoB,GACyC,IADzC;EAC6C,KACzEC,iBADyE,GACtC,EADsC;EACpC,KAC7BC,aAD6B,GACQ,EADR;EACU,KACvCC,2BADuC,GACC,EADD;EACG,KAGlDC,eAHkD,GAGR,IAHQ;EAGJ,KACtCC,iBADsC,GACV,CADU;EACT,KAC7BC,mBAD6B,GACoB,EADpB;EACsB,KACnDC,4BADmD,GACC,IADD;;EACK,KACxDC,iBADwD,GACnC,YAAM;IACjC,IAAIC,GAA0B,GAAG,IAAjC;IAEA,OAAO,YAAM;MACX,IAAIA,GAAJ,EAAS;QACP,OAAOA,GAAP;MACD,CAFD,MAEO,IAAI,OAAO9D,cAAP,KAA0B,WAA9B,EAA2C;QAChD,OAAQ8D,GAAG,GAAG,IAAI9D,cAAJ,CAAmB,UAACC,OAAD,EAAa;UAC5CA,OAAO,CAAC8D,OAAR9D,CAAgB,UAAC+D,KAAD,EAAW;YACzBC,KAAI,CAACC,eAAL,CAAqBF,KAAK,CAACjC,MAA3B,EAAmD,KAAnD;UACD,CAFD9B;QAGD,CAJa,CAAd;MAKD,CANM,MAMA;QACL,OAAO,IAAP;MACF;IACD,CAZD;EAaD,CAhB4B,EADmC;;EAiB5D,KACJzB,KADI,GAC8C;IAChDI,UAAU,EAAE,CADoC;IAEhDI,QAAQ,EAAE;EAFsC,CAD9C;;EAIH,KAcDmF,UAdC,GAcY,UAACjB,IAAD,EAA4D;IACvEkB,MAAM,CAACnE,OAAPmE,CAAelB,IAAfkB,EAAqBL,OAArBK,CAA6B,UAAkBC,KAAlB,EAAkB;MAAA,IAAhBC,GAAG,WAAa;MAAA,IAAXC,KAAK,WAAM;MAC7C,IAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC,OAAQrB,IAAI,CAASoB,GAAT,CAAZ;IACnC,CAFDF;IAIAH,KAAI,CAACrE,OAAL,GAAY4E;MACVC,KAAK,EAAE,KADG;MAEVC,aAAa,EAAE,CAFL;MAGV7F,QAAQ,EAAE,CAHA;MAIV8F,YAAY,EAAE,CAJJ;MAKVC,UAAU,EAAE,CALF;MAMVC,kBAAkB,EAAE,CANV;MAOVC,gBAAgB,EAAE,CAPR;MAQVjF,UAAU,EAAE,KARF;MASVkF,UAAU,EAAE1G,mBATF;MAUV2G,cAAc,EAAEzG,qBAVN;MAWV0G,QAAQ,EAAE,SAAMA,QAAN,GAAM,CAAE,CAXR;MAYV5C,cAAc,EAAdA,cAZU;MAaV6C,WAAW,EAAE;QAAExF,KAAK,EAAE,CAAT;QAAYD,MAAM,EAAE;MAApB,CAbH;MAcV0F,YAAY,EAAE,CAdJ;MAeVC,cAAc,EAAE,GAfN;MAgBVC,cAAc,EAAE,YAhBN;MAiBVC,wBAAwB,EAAE;IAjBhB,GAkBPpC,IAlBO,CAAZ;EAoBD,CAvCA;;EAuCA,KAEOqC,MAFP,GAEgB,YAAM;IACrBtB,KAAI,CAACrE,OAAL,CAAaqF,QAAb,yBAAI,CAACrF,OAAL,CAAaqF,QAAb,CAAwBhB,KAAxB;EACD,CAJA;;EAIA,KAEOuB,OAFP,GAEiB,YAAM;IACtBvB,KAAI,CAACd,MAAL,CAAYsC,MAAZ,CAAmBC,OAAnB,EAA4B3B,OAA5B,CAAoC,UAAC4B,CAAD,EAAE;MAAA,OAAKA,CAAC,EAAN;IAAU,CAAhD;;IACA1B,KAAI,CAACd,MAAL,GAAc,EAAd;IACAc,KAAI,CAAC5D,aAAL,GAAqB,IAArB;EACD,CANA;;EAMA,KAEDuF,SAFC,GAEW,YAAM;IAChB,IAAMC,EAAE,GAAG5B,KAAI,CAACJ,iBAAL,EAAX;;IACAO,MAAM,CAAC0B,MAAP1B,CAAcH,KAAI,CAACN,mBAAnBS,EAAwCL,OAAxCK,CAAgD,UAAC2B,IAAD,EAAK;MAAA,OAAKF,EAAE,IAAFA,kBAAE,CAAEtF,OAAJsF,CAAYE,IAAZF,CAAL;IAAuB,CAA5EzB;IAEA,OAAO,YAAM;MACXyB,EAAE,IAAFA,kBAAE,CAAEG,UAAJH;;MAEA5B,KAAI,CAACuB,OAAL;IACD,CAJD;EAKD,CAXA;;EAWA,KAEDS,WAFC,GAEa,YAAM;IAClBhC,KAAI,CAACL,4BAAL,IAAiC,IAAjC,GAAiC,MAAjC,QAAI,CAACA,4BAAL;;IAEA,IAAMvD,aAAa,GAAG4D,KAAI,CAACrE,OAAL,CAAasG,gBAAb,EAAtB;;IAEA,IAAIjC,KAAI,CAAC5D,aAAL,KAAuBA,aAA3B,EAA0C;MACxC4D,KAAI,CAACuB,OAAL;;MAEAvB,KAAI,CAAC5D,aAAL,GAAqBA,aAArB;;MAEA4D,KAAI,CAACkC,eAAL,CAAqBlC,KAAI,CAACmC,YAA1B,EAAwC;QACtC5D,WAAW,EAAE6D,SADyB;QAEtC3D,QAAQ,EAAE2D;MAF4B,CAAxC;;MAKApC,KAAI,CAACd,MAAL,CAAY/D,IAAZ,CACE6E,KAAI,CAACrE,OAAL,CAAaE,kBAAb,CAAgCmE,KAAhC,EAAsC,UAACtE,IAAD,EAAU;QAC9CsE,KAAI,CAACqC,UAAL,GAAkB3G,IAAlB;;QACAsE,KAAI,CAACsC,cAAL;MACD,CAHD,CADF;;MAOAtC,KAAI,CAACd,MAAL,CAAY/D,IAAZ,CACE6E,KAAI,CAACrE,OAAL,CAAauC,oBAAb,CAAkC8B,KAAlC,EAAwC,UAACrC,MAAD,EAAY;QAClDqC,KAAI,CAACP,iBAAL,GAAyB,CAAzB;;QAEA,IAAIO,KAAI,CAACmC,YAAL,KAAsBxE,MAA1B,EAAkC;UAChC;QACF;;QAEA,IAAIqC,KAAI,CAACZ,oBAAL,KAA8B,IAAlC,EAAwC;UACtCmD,YAAY,CAACvC,KAAI,CAACZ,oBAAN,CAAZmD;UACAvC,KAAI,CAACZ,oBAAL,GAA4B,IAA5B;QACF;;QAEA,IAAMoD,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACrD,WAAD,EAA0B;UACpD,IAAIa,KAAI,CAACb,WAAL,KAAqBA,WAAzB,EAAsC;YACpCa,KAAI,CAACb,WAAL,GAAmBA,WAAnB;;YACAa,KAAI,CAACsB,MAAL;UACF;QACD,CALD;;QAOAtB,KAAI,CAACR,eAAL,GACEQ,KAAI,CAACmC,YAAL,GAAoBxE,MAApB,GAA6B,SAA7B,GAAyC,UAD3C;QAGAqC,KAAI,CAACmC,YAAL,GAAoBxE,MAApB;;QAEAqC,KAAI,CAACsC,cAAL;;QAEAE,mBAAmB,CAAC,IAAD,CAAnBA;QAEAxC,KAAI,CAACZ,oBAAL,GAA4BqD,UAAU,CAAC,YAAM;UAC3CzC,KAAI,CAACZ,oBAAL,GAA4B,IAA5B;UACAY,KAAI,CAACR,eAAL,GAAuB,IAAvB;UACAgD,mBAAmB,CAAC,KAAD,CAAnBA;QACD,CAJqC,EAInCxC,KAAI,CAACrE,OAAL,CAAawF,cAJsB,CAAtC;MAKD,CAjCD,CADF;IAoCD,CArDD,MAqDO,IAAI,CAACnB,KAAI,CAACb,WAAV,EAAuB;MAC5Ba,KAAI,CAACsC,cAAL;IACF;EACD,CA/DA;;EA+DA,KAEOI,OAFP,GAEiB,YAAM;IACtB,OAAO1C,KAAI,CAACqC,UAAL,CAAgBrC,KAAI,CAACrE,OAAL,CAAaC,UAAb,GAA0B,OAA1B,GAAoC,QAApD,CAAP;EACD,CAJA;;EAIA,KAEO+G,eAFP,GAEyBC,IAAI,CAC5B;IAAA,OAAM,CACJ5C,KAAI,CAACrE,OAAL,CAAaX,KADT,EAEJgF,KAAI,CAACrE,OAAL,CAAa+E,YAFT,EAGJV,KAAI,CAACrE,OAAL,CAAauF,YAHT,EAIJlB,KAAI,CAACrE,OAAL,CAAamF,UAJT,EAKJd,KAAI,CAACV,aALD,CAAN;EAOA,CAR4B,EAQ5B,UAACtE,KAAD,EAAQ0F,YAAR,EAAsBQ,YAAtB,EAAoCJ,UAApC,EAAgDxB,aAAhD,EAAkE;IAChE,IAAMxE,GAAG,GACPkF,KAAI,CAACT,2BAAL,CAAiCsD,MAAjC,GAA0C,CAA1C,GACIpI,IAAI,CAACK,GAALL,CAAQqI,KAARrI,OAAYuF,KAAI,CAACT,2BAAjB9E,CADJ,GAEI,CAHN;IAIAuF,KAAI,CAACT,2BAAL,GAAmC,EAAnC;;IAEA,IAAMwD,YAAY,GAAG/C,KAAI,CAACX,iBAAL,CAAuB2D,KAAvB,CAA6B,CAA7B,EAAgClI,GAAhC,CAArB;;IAEA,KAAK,IAAII,GAAC,GAAGJ,GAAb,EAAkBI,GAAC,GAAGF,KAAtB,EAA6BE,GAAC,EAA9B,EAAkC;MAChC,IAAMmF,GAAG,GAAGS,UAAU,CAAC5F,GAAD,CAAtB;MACA,IAAM+H,YAAY,GAAG3D,aAAa,CAACe,GAAD,CAAlC;MACA,IAAM7F,KAAK,GAAGuI,YAAY,CAAC7H,GAAC,GAAG,CAAL,CAAZ6H,GACVA,YAAY,CAAC7H,GAAC,GAAG,CAAL,CAAZ6H,CAAqBlI,GADXkI,GAEVrC,YAAY,GAAGQ,YAFnB;MAGA,IAAMgC,IAAI,GACR,OAAOD,YAAP,KAAwB,QAAxB,GACIA,YADJ,GAEIjD,KAAI,CAACrE,OAAL,CAAawH,YAAb,CAA0BjI,GAA1B,CAHN;MAIA,IAAML,GAAG,GAAGL,KAAK,GAAG0I,IAApB;MACAH,YAAY,CAAC7H,GAAD,CAAZ6H,GAAkB;QAAE1I,KAAK,EAAEa,GAAT;QAAYV,KAAK,EAALA,KAAZ;QAAmB0I,IAAI,EAAJA,IAAnB;QAAyBrI,GAAG,EAAHA,GAAzB;QAA8BwF,GAAG,EAAHA;MAA9B,CAAlB0C;IACF;;IAEA/C,KAAI,CAACX,iBAAL,GAAyB0D,YAAzB;IAEA,OAAOA,YAAP;EACD,CAlC2B,EAmC5B;IACE1C,GAAG,EAAE+C,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,IAAyC,iBADhD;IAEE5C,KAAK,EAAE;MAAA,OAAMR,KAAI,CAACrE,OAAL,CAAa6E,KAAnB;IAAwB;EAFjC,CAnC4B,CAF7B;EAyCA,KAED8B,cAFC,GAEgBM,IAAI,CACnB;IAAA,OAAM,CAAC5C,KAAI,CAAC2C,eAAL,EAAD,EAAyB3C,KAAI,CAAC0C,OAAL,EAAzB,EAAyC1C,KAAI,CAACmC,YAA9C,CAAN;EAAiE,CAD9C,EAEnB,UAACY,YAAD,EAAeQ,SAAf,EAA0BpB,YAA1B,EAA2C;IACzC,IAAM5H,KAAK,GAAG+H,cAAc,CAAC;MAC3BS,YAAY,EAAZA,YAD2B;MAE3BQ,SAAS,EAATA,SAF2B;MAG3BpB,YAAY,EAAZA;IAH2B,CAAD,CAA5B;;IAKA,IACE5H,KAAK,CAACI,UAANJ,KAAqByF,KAAI,CAACzF,KAAL,CAAWI,UAAhCJ,IACAA,KAAK,CAACQ,QAANR,KAAmByF,KAAI,CAACzF,KAAL,CAAWQ,QAFhC,EAGE;MACAiF,KAAI,CAACzF,KAAL,GAAaA,KAAb;;MACAyF,KAAI,CAACsB,MAAL;IACF;;IACA,OAAOtB,KAAI,CAACzF,KAAZ;EACD,CAhBkB,EAiBnB;IACE8F,GAAG,EAAE+C,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,IAAyC,gBADhD;IAEE5C,KAAK,EAAE;MAAA,OAAMR,KAAI,CAACrE,OAAL,CAAa6E,KAAnB;IAAwB;EAFjC,CAjBmB,CAFpB;EAuBA,KAEOgD,UAFP,GAEoBZ,IAAI,CACvB;IAAA,OAAM,CACJ5C,KAAI,CAACrE,OAAL,CAAaoF,cADT,EAEJf,KAAI,CAACzF,KAFD,EAGJyF,KAAI,CAACrE,OAAL,CAAaf,QAHT,EAIJoF,KAAI,CAACrE,OAAL,CAAaX,KAJT,CAAN;EAMA,CAPuB,EAOvB,UAAC+F,cAAD,EAAiBxG,KAAjB,EAAwBK,QAAxB,EAAkCI,KAAlC,EAA4C;IAC1C,OAAO+F,cAAc,cAChBxG,KADgB,EACX;MACRK,QAAQ,EAARA,QADQ;MAERI,KAAK,EAAEA;IAFC,CADW,EAArB;EAKD,CAbsB,EAcvB;IACEqF,GAAG,EAAE+C,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,IAAyC,YADhD;IAEE5C,KAAK,EAAE;MAAA,OAAMR,KAAI,CAACrE,OAAL,CAAa6E,KAAnB;IAAwB;EAFjC,CAduB,CAFxB;;EAoBA,KAEDiD,gBAFC,GAEkB,UAAC3B,IAAD,EAAwB;IACzC,IAAM4B,aAAa,GAAG1D,KAAI,CAACrE,OAAL,CAAayF,cAAnC;IACA,IAAMuC,QAAQ,GAAG7B,IAAI,CAAC8B,YAAL9B,CAAkB4B,aAAlB5B,CAAjB;;IAEA,IAAI,CAAC6B,QAAL,EAAe;MACbE,OAAO,CAACC,IAARD,CAC6BH,6CAC5B,gCAFDG;MAGA,OAAO,CAAC,CAAR;IACF;;IAEA,OAAOE,QAAQ,CAACJ,QAAD,EAAW,EAAX,CAAf;EACD,CAdA;;EAcA,KAEO1D,eAFP,GAEyB,UAAC6B,IAAD,EAAqBkC,KAArB,EAAwC;IAAA;;IAChE,IAAM3J,KAAK,GAAG2F,KAAI,CAACyD,gBAAL,CAAsB3B,IAAtB,CAAd;;IAEA,IAAMmC,IAAI,GAAGjE,KAAI,CAACX,iBAAL,CAAuBhF,KAAvB,CAAb;;IACA,IAAI,CAAC4J,IAAL,EAAW;MACT;IACF;;IAEA,IAAMC,QAAQ,GAAGlE,KAAI,CAACN,mBAAL,CAAyBuE,IAAI,CAAC5D,GAA9B,CAAjB;;IAEA,IAAMuB,EAAE,GAAG5B,KAAI,CAACJ,iBAAL,EAAX;;IAEA,IAAI,CAACkC,IAAI,CAACqC,WAAV,EAAuB;MACrB,IAAID,QAAJ,EAAc;QACZtC,EAAE,QAAFA,GAAE,MAAFA,KAAE,CAAErF,SAAJqF,CAAcsC,QAAdtC;QACA,OAAO5B,KAAI,CAACN,mBAAL,CAAyBuE,IAAI,CAAC5D,GAA9B,CAAP;MACF;;MACA;IACF;;IAEA,IAAI,CAAC6D,QAAD,IAAaA,QAAQ,KAAKpC,IAA9B,EAAoC;MAClC,IAAIoC,QAAJ,EAAc;QACZtC,EAAE,QAAFA,GAAE,MAAFA,KAAE,CAAErF,SAAJqF,CAAcsC,QAAdtC;MACF;;MACA5B,KAAI,CAACN,mBAAL,CAAyBuE,IAAI,CAAC5D,GAA9B,IAAqCyB,IAArC;MACAF,EAAE,QAAFA,GAAE,MAAFA,KAAE,CAAEtF,OAAJsF,CAAYE,IAAZF;IACF;;IAEA,IAAMwC,gBAAgB,GAAGpE,KAAI,CAACrE,OAAL,CAAayC,cAAb,CAA4B0D,IAA5B,EAAkC9B,KAAlC,CAAzB;;IAEA,IAAMqE,QAAQ,4BAAGrE,KAAI,CAACV,aAAL,CAAmB2E,IAAI,CAAC5D,GAAxB,CAAH,KAAmC4D,IAAnC,GAAmCA,qBAAnC,GAAmCA,IAAI,CAACf,IAAtD;IAEA,IAAMoB,KAAK,GAAGF,gBAAgB,GAAGC,QAAjC;;IAEA,IAAIC,KAAK,KAAK,CAAd,EAAiB;MAAA;;MACf,IACEL,IAAI,CAACzJ,KAALyJ,GAAajE,KAAI,CAACmC,YAAlB8B,IACAjE,KAAI,CAACb,WADL8E,IAEAjE,KAAI,CAACR,eAAL,KAAyB,UAH3B,EAIE;QACA,IAAI4D,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,IAAyCpD,KAAI,CAACrE,OAAL,CAAa6E,KAA1D,EAAiE;UAC/DqD,OAAO,CAACU,IAARV,CAAa,YAAbA,EAA2BS,KAA3BT;QACF;;QAEA7D,KAAI,CAACkC,eAAL,CAAqBlC,KAAI,CAACmC,YAA1B,EAAwC;UACtC5D,WAAW,EAAGyB,KAAI,CAACP,iBAAL,IAA0B6E,KADF;UAEtC7F,QAAQ,EAAE2D;QAF4B,CAAxC;MAIF;;MAEApC,KAAI,CAACT,2BAAL,CAAiCpE,IAAjC,CAAsCd,KAAtC;;MACA2F,KAAI,CAACV,aAAL,GACKiB,kBAAI,CAACjB,aAAL,GACF2E,8BAAI,CAAC5D,GAAL4D,IAAWG,gBAAXH,EACFO,SAFI,EADL;;MAIAxE,KAAI,CAACsB,MAAL;IACF;EACD,CA3DA;;EA2DA,KAEDlD,cAFC,GAEgB,UAAC0D,IAAD,EAA+B;IAC9C,IAAI,CAACA,IAAL,EAAW;MACT;IACF;;IAEA9B,KAAI,CAACC,eAAL,CAAqB6B,IAArB,EAA2B,IAA3B;EACD,CARA;;EAQA,KAED2C,eAFC,GAEiB7B,IAAI,CACpB;IAAA,OAAM,CAAC5C,KAAI,CAACwD,UAAL,EAAD,EAAoBxD,KAAI,CAAC2C,eAAL,EAApB,CAAN;EAAiD,CAD7B,EAEpB,UAAC+B,OAAD,EAAU3B,YAAV,EAA2B;IACzB,IAAM4B,YAA2B,GAAG,EAApC;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGH,OAAO,CAAC7B,MAA9B,EAAsC+B,CAAC,GAAGC,GAA1C,EAA+CD,CAAC,EAAhD,EAAoD;MAClD,IAAM1J,GAAC,GAAGwJ,OAAO,CAACE,CAAD,CAAjB;MACA,IAAME,WAAW,GAAG/B,YAAY,CAAC7H,GAAD,CAAhC;MAEAyJ,YAAY,CAACxJ,IAAbwJ,CAAkBG,WAAlBH;IACF;;IAEA,OAAOA,YAAP;EACD,CAbmB,EAcpB;IACEtE,GAAG,EAAE+C,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,IAAyC,YADhD;IAEE5C,KAAK,EAAE;MAAA,OAAMR,KAAI,CAACrE,OAAL,CAAa6E,KAAnB;IAAwB;EAFjC,CAdoB,CAFrB;;EAoBA,KAEDuE,qBAFC,GAEuB,UAACrG,QAAD,EAAmBsG,KAAnB,EAA8C;IACpE,IAAMrH,MAAM,GAAGqC,KAAI,CAACmC,YAApB;;IACA,IAAMe,IAAI,GAAGlD,KAAI,CAAC0C,OAAL,EAAb;;IAEA,IAAIsC,KAAK,KAAK,MAAd,EAAsB;MACpB,IAAItG,QAAQ,IAAIf,MAAhB,EAAwB;QACtBqH,KAAK,GAAG,OAARA;MACD,CAFD,MAEO,IAAItG,QAAQ,IAAIf,MAAM,GAAGuF,IAAzB,EAA+B;QACpC8B,KAAK,GAAG,KAARA;MACD,CAFM,MAEA;QACLA,KAAK,GAAG,OAARA;MACF;IACF;;IAEA,IAAIA,KAAK,KAAK,OAAd,EAAuB;MACrB,OAAOtG,QAAP;IACD,CAFD,MAEO,IAAIsG,KAAK,KAAK,KAAd,EAAqB;MAC1B,OAAOtG,QAAQ,GAAGwE,IAAlB;IACD,CAFM,MAEA,IAAI8B,KAAK,KAAK,QAAd,EAAwB;MAC7B,OAAOtG,QAAQ,GAAGwE,IAAI,GAAG,CAAzB;IACF;;IACA,OAAOxE,QAAP;EACD,CAxBA;;EAwBA,KAEDuG,cAFC,GAEgB,UACfvG,QADe,EAGZwG,KAHY,EAGZ;IAAA,+BADoD,EACpD,GADsDA,KACtD;IAAA,IADsDC,oBAAvDH,KACC;IAAA,IADDA,KAAK,4BAAG,OAAH,GAAUG,WACd;IAAA,IADgB1G,QAAQ,SAARA,QAChB;;IACH,IAAM9C,OAAO,GAAG;MACd4C,WAAW,EAAE6D,SADC;MAEd3D,QAAQ,EAARA,QAFc;MAGd2G,IAAI,EAAE;IAHQ,CAAhB;;IAKApF,KAAI,CAACkC,eAAL,CAAqBlC,KAAI,CAAC+E,qBAAL,CAA2BrG,QAA3B,EAAqCsG,KAArC,CAArB,EAAkErJ,OAAlE;EACD,CAZA;;EAYA,KAED0J,aAFC,GAEe,UACdhL,KADc,EAGXiL,MAHW,EAGX;IAAA,gCADkD,EAClD,GADoDA,MACpD;IAAA,IADoDC,oBAArDP,KACC;IAAA,IADDA,KAAK,4BAAG,MAAH,GAASO,WACb;IAAA,IADe9G,QAAQ,SAARA,QACf;;IACHuB,KAAI,CAACL,4BAAL,GAAoC,IAApC;IAEA,IAAMhC,MAAM,GAAGqC,KAAI,CAACmC,YAApB;;IACA,IAAMe,IAAI,GAAGlD,KAAI,CAAC0C,OAAL,EAAb;;IACA,IAAQ1H,KAAK,GAAKgF,KAAI,CAACrE,OAAL,CAAVX,KAAR;;IAEA,IAAM+H,YAAY,GAAG/C,KAAI,CAAC2C,eAAL,EAArB;;IACA,IAAMmC,WAAW,GAAG/B,YAAY,CAACtI,IAAI,CAACC,GAALD,CAAS,CAATA,EAAYA,IAAI,CAACK,GAALL,CAASJ,KAATI,EAAgBO,KAAK,GAAG,CAAxBP,CAAZA,CAAD,CAAhC;;IAEA,IAAI,CAACqK,WAAL,EAAkB;MAChB,MAAM,IAAIU,KAAJ,CAA+CnL,4CAA/C,CAAN;IACF;;IAEA,IAAI2K,KAAK,KAAK,MAAd,EAAsB;MACpB,IAAIF,WAAW,CAACjK,GAAZiK,IAAmBnH,MAAM,GAAGuF,IAATvF,GAAgBqC,KAAI,CAACrE,OAAL,CAAakF,gBAApD,EAAsE;QACpEmE,KAAK,GAAG,KAARA;MACD,CAFD,MAEO,IACLF,WAAW,CAACtK,KAAZsK,IACAnH,MAAM,GAAGqC,KAAI,CAACrE,OAAL,CAAaiF,kBAFjB,EAGL;QACAoE,KAAK,GAAG,OAARA;MACD,CALM,MAKA;QACL;MACF;IACF;;IAEA,IAAMS,6BAA6B,GAAG,SAAhCA,6BAAgC,CAACX,WAAD,EAA8B;MAClE,IAAMpG,QAAQ,GACZsG,KAAK,KAAK,KAAVA,GACIF,WAAW,CAACjK,GAAZiK,GAAkB9E,KAAI,CAACrE,OAAL,CAAakF,gBADnCmE,GAEIF,WAAW,CAACtK,KAAZsK,GAAoB9E,KAAI,CAACrE,OAAL,CAAaiF,kBAHvC;MAKA,OAAOZ,KAAI,CAAC+E,qBAAL,CAA2BrG,QAA3B,EAAqCsG,KAArC,CAAP;IACD,CAPD;;IASA,IAAMtG,QAAQ,GAAG+G,6BAA6B,CAACX,WAAD,CAA9C;;IAEA,IAAIrK,IAAI,CAAC4D,KAAL5D,CAAWiE,QAAXjE,MAAyBA,IAAI,CAAC4D,KAAL5D,CAAWkD,MAAXlD,CAA7B,EAAiD;MAC/C;IACF;;IAEA,IAAMkB,OAAO,GAAG;MACd4C,WAAW,EAAE6D,SADC;MAEd3D,QAAQ,EAARA;IAFc,CAAhB;;IAIAuB,KAAI,CAACkC,eAAL,CAAqBxD,QAArB,EAA+B/C,OAA/B;;IAEA,IAAM+J,SAAS,GAAGvF,MAAM,CAACwF,IAAPxF,CAAYH,KAAI,CAACN,mBAAjBS,EAAsC0C,MAAtC1C,GAA+C,CAAjE;;IAEA,IAAIuF,SAAJ,EAAe;MACb1F,KAAI,CAACL,4BAAL,GAAoC,YAAM;QACxCK,KAAI,CAACqF,aAAL,CAAmBhL,KAAnB,EAA0B;UAAE2K,KAAK,EAALA,KAAF;UAASvG,QAAQ,EAARA;QAAT,CAA1B;MACD,CAFD;IAGF;EACD,CA5DA;;EA4DA,KAEDmH,QAFC,GAEU,UAACrH,WAAD,EAAsB5C,OAAtB,EAAiE;IAC1EqE,KAAI,CAACkC,eAAL,CAAqBlC,KAAI,CAACmC,YAA1B,EAAwC;MACtC5D,WAAW,EAAXA,WADsC;MAEtCE,QAAQ,EAAE9C,OAAO,IAAPA,uBAAO,CAAE8C;IAFmB,CAAxC;EAID,CAPA;;EAOA,KAEDoH,YAFC,GAEc;IAAA;;IAAA,OACb,CAAC,+BAAI,CAAClD,eAAL,GAAuB3C,KAAI,CAACrE,OAAL,CAAaX,KAAb,GAAqB,CAA5C,MAA8C,IAA9C,GAA8C,MAA9C,wBAAgDH,IAAhD,KACCmF,KAAI,CAACrE,OAAL,CAAa+E,YADf,IAEAV,KAAI,CAACrE,OAAL,CAAauF,YAFb,GAGAlB,KAAI,CAACrE,OAAL,CAAagF,UAJA;EAIU,CANxB;;EAMwB,KAEjBuB,eAFiB,GAEC,UACxBvE,MADwB,EASrBmI,KATqB,EASrB;IAAA,IANDvH,WAAW,SAAXA,WAMC;IAAA,IALDE,QAAQ,SAARA,QAKC;;IACHuB,KAAI,CAACrE,OAAL,CAAaoK,UAAb,CAAwBpI,MAAxB,EAAgC;MAAEc,QAAQ,EAARA,QAAF;MAAYF,WAAW,EAAXA;IAAZ,CAAhC,EAA2DyB,KAA3D;EACD,CAbwB;;EAaxB,KAEDgG,OAFC,GAES,YAAM;IACdhG,KAAI,CAACV,aAAL,GAAqB,EAArB;;IACAU,KAAI,CAACsB,MAAL;EACD,CALA;;EA/aC,KAAKpB,UAAL,CAAgBjB,KAAhB;EACA,KAAKoD,UAAL,GAAkB,KAAK1G,OAAL,CAAasF,WAA/B;EACA,KAAKkB,YAAL,GAAoB,KAAKxG,OAAL,CAAa8E,aAAjC;EACA,KAAKpB,iBAAL,GAAyB,KAAK1D,OAAL,CAAa0F,wBAAtC;EACA,KAAKhC,iBAAL,CAAuBS,OAAvB,CAA+B,UAACmE,IAAD,EAAU;IACvCjE,KAAI,CAACV,aAAL,CAAmB2E,IAAI,CAAC5D,GAAxB,IAA+B4D,IAAI,CAACf,IAApC;EACD,CAFD;EAIA,KAAKZ,cAAL;AACF,CAlDF;;AAgeA,IAAM2D,uBAAuB,GAAG,SAA1BA,uBAA0B,CAC9BC,GAD8B,EAE9BC,IAF8B,EAG9BC,eAH8B,EAI9B9F,KAJ8B,EAK3B;EACH,OAAO4F,GAAG,IAAIC,IAAd,EAAoB;IAClB,IAAME,MAAM,GAAI,CAACH,GAAG,GAAGC,IAAP,IAAe,CAAf,GAAoB,CAApC;IACA,IAAMG,YAAY,GAAGF,eAAe,CAACC,MAAD,CAApC;;IAEA,IAAIC,YAAY,GAAGhG,KAAnB,EAA0B;MACxB4F,GAAG,GAAGG,MAAM,GAAG,CAAfH;IACD,CAFD,MAEO,IAAII,YAAY,GAAGhG,KAAnB,EAA0B;MAC/B6F,IAAI,GAAGE,MAAM,GAAG,CAAhBF;IACD,CAFM,MAEA;MACL,OAAOE,MAAP;IACF;EACF;;EAEA,IAAIH,GAAG,GAAG,CAAV,EAAa;IACX,OAAOA,GAAG,GAAG,CAAb;EACD,CAFD,MAEO;IACL,OAAO,CAAP;EACF;AACD,CAxBD;;AA0BA,SAAS5D,cAAT,CAQGiE,KARH,EAQG;EAAA,IAPDxD,YAAY,SAAZA,YAOC;EAAA,IANDQ,SAAS,SAATA,SAMC;EAAA,IALDpB,YAAY,SAAZA,YAKC;EACD,IAAMnH,KAAK,GAAG+H,YAAY,CAACF,MAAbE,GAAsB,CAApC;;EACA,IAAMyD,SAAS,GAAG,SAAZA,SAAY,CAACnM,KAAD,EAAc;IAAA,OAAK0I,YAAY,CAAC1I,KAAD,CAAZ0I,CAAqBvI,KAA1B;EAA+B,CAA/D;;EAEA,IAAMG,UAAU,GAAGsL,uBAAuB,CAAC,CAAD,EAAIjL,KAAJ,EAAWwL,SAAX,EAAsBrE,YAAtB,CAA1C;EACA,IAAIpH,QAAQ,GAAGJ,UAAf;;EAEA,OACEI,QAAQ,GAAGC,KAAXD,IACAgI,YAAY,CAAChI,QAAD,CAAZgI,CAAwBlI,GAAxBkI,GAA8BZ,YAAY,GAAGoB,SAF/C,EAGE;IACAxI,QAAQ;EACV;;EAEA,OAAO;IAAEJ,UAAU,EAAVA,UAAF;IAAcI,QAAQ,EAARA;EAAd,CAAP;AACF","names":["defaultKeyExtractor","index","defaultRangeExtractor","range","start","Math","max","startIndex","overscan","end","min","endIndex","count","arr","i","push","memoRectCallback","instance","cb","prev","height","width","rect","options","horizontal","observeElementRect","observer","ResizeObserver","entries","_entries$","contentRect","_entries$2","scrollElement","getBoundingClientRect","observe","unobserve","observeWindowRect","memoizedCallback","onResize","innerWidth","innerHeight","addEventListener","capture","passive","removeEventListener","scrollProps","element","window","createOffsetObserver","mode","propX","propY","prevX","prevY","scroll","offset","onScroll","e","target","currentTarget","scrollX","scrollY","observeElementOffset","observeWindowOffset","measureElement","round","windowScroll","adjustments","_ref$adjustments","behavior","toOffset","scrollTo","_instance$scrollEleme2","elementScroll","_ref2$adjustments","_instance$scrollEleme4","Virtualizer","opts","unsubs","isScrolling","isScrollingTimeoutId","measurementsCache","itemSizeCache","pendingMeasuredCacheIndexes","scrollDirection","scrollAdjustments","measureElementCache","pendingScrollToIndexCallback","getResizeObserver","_ro","forEach","entry","_this","_measureElement","setOptions","Object","_ref3","key","value","_extends","debug","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","onChange","initialRect","scrollMargin","scrollingDelay","indexAttribute","initialMeasurementsCache","notify","cleanup","filter","Boolean","d","_didMount","ro","values","node","disconnect","_willUpdate","getScrollElement","_scrollToOffset","scrollOffset","undefined","scrollRect","calculateRange","clearTimeout","onIsScrollingChange","setTimeout","getSize","getMeasurements","memo","length","apply","measurements","slice","measuredSize","size","estimateSize","process","env","NODE_ENV","outerSize","getIndexes","indexFromElement","attributeName","indexStr","getAttribute","console","warn","parseInt","_sync","item","prevNode","isConnected","measuredItemSize","itemSize","delta","info","_extends2","getVirtualItems","indexes","virtualItems","k","len","measurement","getOffsetForAlignment","align","scrollToOffset","_temp","_ref4$align","sync","scrollToIndex","_temp2","_ref5$align","Error","getOffsetForIndexAndAlignment","isDynamic","keys","scrollBy","getTotalSize","_ref6","scrollToFn","measure","findNearestBinarySearch","low","high","getCurrentValue","middle","currentValue","_ref7","getOffset"],"sources":["/home/shama/webapps/ionicblog/node_modules/@tanstack/virtual-core/src/index.ts"],"sourcesContent":["import { memo } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n}\n\ninterface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nconst memoRectCallback = (\n  instance: Virtualizer<any, any>,\n  cb: (rect: Rect) => void,\n) => {\n  let prev: Rect = { height: -1, width: -1 }\n\n  return (rect: Rect) => {\n    if (\n      instance.options.horizontal\n        ? rect.width !== prev.width\n        : rect.height !== prev.height\n    ) {\n      cb(rect)\n    }\n\n    prev = rect\n  }\n}\n\nexport const observeElementRect = (\n  instance: Virtualizer<any, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const observer = new ResizeObserver((entries) => {\n    cb({\n      width: entries[0]?.contentRect.width as number,\n      height: entries[0]?.contentRect.height as number,\n    })\n  })\n\n  if (!instance.scrollElement) {\n    return\n  }\n\n  cb(instance.scrollElement.getBoundingClientRect())\n\n  observer.observe(instance.scrollElement)\n\n  return () => {\n    observer.unobserve(instance.scrollElement)\n  }\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<any, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const memoizedCallback = memoRectCallback(instance, cb)\n  const onResize = () =>\n    memoizedCallback({\n      width: instance.scrollElement.innerWidth,\n      height: instance.scrollElement.innerHeight,\n    })\n\n  if (!instance.scrollElement) {\n    return\n  }\n\n  onResize()\n\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true,\n  })\n\n  return () => {\n    instance.scrollElement.removeEventListener('resize', onResize)\n  }\n}\n\ntype ObserverMode = 'element' | 'window'\n\nconst scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY'],\n} as const\n\nconst createOffsetObserver = (mode: ObserverMode) => {\n  return (instance: Virtualizer<any, any>, cb: (offset: number) => void) => {\n    if (!instance.scrollElement) {\n      return\n    }\n\n    const propX = scrollProps[mode][0]\n    const propY = scrollProps[mode][1]\n\n    let prevX: number = instance.scrollElement[propX]\n    let prevY: number = instance.scrollElement[propY]\n\n    const scroll = () => {\n      const offset =\n        instance.scrollElement[instance.options.horizontal ? propX : propY]\n\n      cb(offset)\n    }\n\n    scroll()\n\n    const onScroll = (e: Event) => {\n      const target = e.currentTarget as HTMLElement & Window\n      const scrollX = target[propX]\n      const scrollY = target[propY]\n\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll()\n      }\n\n      prevX = scrollX\n      prevY = scrollY\n    }\n\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      instance.scrollElement.removeEventListener('scroll', onScroll)\n    }\n  }\n}\n\nexport const observeElementOffset = createOffsetObserver('element')\nexport const observeWindowOffset = createOffsetObserver('window')\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (instance: Virtualizer<TScrollElement, TItemElement>) => void\n  measureElement?: (\n    el: TItemElement,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => number[]\n  scrollMargin?: number\n  scrollingDelay?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: VirtualItem[]\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: (void | (() => void))[] = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  isScrolling: boolean = false\n  private isScrollingTimeoutId: ReturnType<typeof setTimeout> | null = null\n  measurementsCache: VirtualItem[] = []\n  private itemSizeCache: Record<Key, number> = {}\n  private pendingMeasuredCacheIndexes: number[] = []\n  private scrollRect: Rect\n  scrollOffset: number\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments: number = 0\n  private measureElementCache: Record<Key, TItemElement> = {}\n  private pendingScrollToIndexCallback: (() => void) | null = null\n  private getResizeObserver = (() => {\n    let _ro: ResizeObserver | null = null\n\n    return () => {\n      if (_ro) {\n        return _ro\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return (_ro = new ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            this._measureElement(entry.target as TItemElement, false)\n          })\n        }))\n      } else {\n        return null\n      }\n    }\n  })()\n  range: { startIndex: number; endIndex: number } = {\n    startIndex: 0,\n    endIndex: 0,\n  }\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n    this.scrollRect = this.options.initialRect\n    this.scrollOffset = this.options.initialOffset\n    this.measurementsCache = this.options.initialMeasurementsCache\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache[item.key] = item.size\n    })\n\n    this.calculateRange()\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      ...opts,\n    }\n  }\n\n  private notify = () => {\n    this.options.onChange?.(this)\n  }\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n  }\n\n  _didMount = () => {\n    const ro = this.getResizeObserver()\n    Object.values(this.measureElementCache).forEach((node) => ro?.observe(node))\n\n    return () => {\n      ro?.disconnect()\n\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    this.pendingScrollToIndexCallback?.()\n\n    const scrollElement = this.options.getScrollElement()\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      this.scrollElement = scrollElement\n\n      this._scrollToOffset(this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.calculateRange()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset) => {\n          this.scrollAdjustments = 0\n\n          if (this.scrollOffset === offset) {\n            return\n          }\n\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId)\n            this.isScrollingTimeoutId = null\n          }\n\n          const onIsScrollingChange = (isScrolling: boolean) => {\n            if (this.isScrolling !== isScrolling) {\n              this.isScrolling = isScrolling\n              this.notify()\n            }\n          }\n\n          this.scrollDirection =\n            this.scrollOffset < offset ? 'forward' : 'backward'\n\n          this.scrollOffset = offset\n\n          this.calculateRange()\n\n          onIsScrollingChange(true)\n\n          this.isScrollingTimeoutId = setTimeout(() => {\n            this.isScrollingTimeoutId = null\n            this.scrollDirection = null\n            onIsScrollingChange(false)\n          }, this.options.scrollingDelay)\n        }),\n      )\n    } else if (!this.isScrolling) {\n      this.calculateRange()\n    }\n  }\n\n  private getSize = () => {\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getMeasurements = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.itemSizeCache,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, itemSizeCache) => {\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n        const measuredSize = itemSizeCache[key]\n        const start = measurements[i - 1]\n          ? measurements[i - 1]!.end\n          : paddingStart + scrollMargin\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n        const end = start + size\n        measurements[i] = { index: i, start, size, end, key }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n    (measurements, outerSize, scrollOffset) => {\n      const range = calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset,\n      })\n      if (\n        range.startIndex !== this.range.startIndex ||\n        range.endIndex !== this.range.endIndex\n      ) {\n        this.range = range\n        this.notify()\n      }\n      return this.range\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.range,\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({\n        ...range,\n        overscan,\n        count: count,\n      })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (node: TItemElement, _sync: boolean) => {\n    const index = this.indexFromElement(node)\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n\n    const prevNode = this.measureElementCache[item.key]\n\n    const ro = this.getResizeObserver()\n\n    if (!node.isConnected) {\n      if (prevNode) {\n        ro?.unobserve(prevNode)\n        delete this.measureElementCache[item.key]\n      }\n      return\n    }\n\n    if (!prevNode || prevNode !== node) {\n      if (prevNode) {\n        ro?.unobserve(prevNode)\n      }\n      this.measureElementCache[item.key] = node\n      ro?.observe(node)\n    }\n\n    const measuredItemSize = this.options.measureElement(node, this)\n\n    const itemSize = this.itemSizeCache[item.key] ?? item.size\n\n    const delta = measuredItemSize - itemSize\n\n    if (delta !== 0) {\n      if (\n        item.start < this.scrollOffset &&\n        this.isScrolling &&\n        this.scrollDirection === 'backward'\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(index)\n      this.itemSizeCache = {\n        ...this.itemSizeCache,\n        [item.key]: measuredItemSize,\n      }\n      this.notify()\n    }\n  }\n\n  measureElement = (node: TItemElement | null) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, true)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: VirtualItem[] = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const offset = this.scrollOffset\n    const size = this.getSize()\n\n    if (align === 'auto') {\n      if (toOffset <= offset) {\n        align = 'start'\n      } else if (toOffset >= offset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      return toOffset\n    } else if (align === 'end') {\n      return toOffset - size\n    } else if (align === 'center') {\n      return toOffset - size / 2\n    }\n    return toOffset\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    const options = {\n      adjustments: undefined,\n      behavior,\n      sync: false,\n    }\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), options)\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    this.pendingScrollToIndexCallback = null\n\n    const offset = this.scrollOffset\n    const size = this.getSize()\n    const { count } = this.options\n\n    const measurements = this.getMeasurements()\n    const measurement = measurements[Math.max(0, Math.min(index, count - 1))]\n\n    if (!measurement) {\n      throw new Error(`VirtualItem not found for index = ${index}`)\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= offset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (\n        measurement.start <=\n        offset + this.options.scrollPaddingStart\n      ) {\n        align = 'start'\n      } else {\n        return\n      }\n    }\n\n    const getOffsetForIndexAndAlignment = (measurement: VirtualItem) => {\n      const toOffset =\n        align === 'end'\n          ? measurement.end + this.options.scrollPaddingEnd\n          : measurement.start - this.options.scrollPaddingStart\n\n      return this.getOffsetForAlignment(toOffset, align)\n    }\n\n    const toOffset = getOffsetForIndexAndAlignment(measurement)\n\n    if (Math.round(toOffset) === Math.round(offset)) {\n      return\n    }\n\n    const options = {\n      adjustments: undefined,\n      behavior,\n    }\n    this._scrollToOffset(toOffset, options)\n\n    const isDynamic = Object.keys(this.measureElementCache).length > 0\n\n    if (isDynamic) {\n      this.pendingScrollToIndexCallback = () => {\n        this.scrollToIndex(index, { align, behavior })\n      }\n    }\n  }\n\n  scrollBy = (adjustments: number, options?: { behavior: ScrollBehavior }) => {\n    this._scrollToOffset(this.scrollOffset, {\n      adjustments,\n      behavior: options?.behavior,\n    })\n  }\n\n  getTotalSize = () =>\n    (this.getMeasurements()[this.options.count - 1]?.end ||\n      this.options.paddingStart) -\n    this.options.scrollMargin +\n    this.options.paddingEnd\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = {}\n    this.notify()\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: VirtualItem[]\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n"]},"metadata":{},"sourceType":"module"}